<?php
/**
 * @file
 * Provides integration with Moneris API payment method (on-site).
 */

define('COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED', 'moneris_authorised');
define('COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED', 'moneris_reversed');

define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE', '00');
define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH', '01');
define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE', '02');
define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND', '04');

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_moneris_api_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['commerce_moneris_api'] = array(
    'title' => 'Moneris API',
    'display_title' => t('Credit card'),
    'description' => t('Moneris API payment method (on-site)'),
  );

  return $payment_methods;
}

/**
 * Implements hook_commerce_payment_transaction_status_info().
 *
 * We needed new success statuses for authorisation and reverse transactions,
 * as we cannot use standard COMMERCE_PAYMENT_STATUS_SUCCESS, because these
 * transactions should not be included in order balance calculations.
 */
function commerce_moneris_api_commerce_payment_transaction_status_info() {
  $statuses = array();

  $statuses[COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED] = array(
    'status' => COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED,
    'title' => t('Authorised'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED] = array(
    'status' => COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED,
    'title' => t('Reversed'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  return $statuses;
}

/**
 * Implements hook_menu().
 */
function commerce_moneris_api_menu() {
  $items = array();

  // The Refund will credit a specified amount to the cardholderâ€™s credit card.
  // A Refund can be sent up to the full value of the original Capture or Purchase.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-refund'] = array(
    'title' => 'Refund',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_refund_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_refund',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  // The Capture transaction is used to secure the funds locked by a PreAuth
  // or ReAuth transaction. A PreAuth or ReAuth transaction can only be captured
  // once.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_capture_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_capture',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  // Reverse.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-reverse'] = array(
    'title' => 'Reverse',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_reverse_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_reverse',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 3,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  // ReAuth.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-reauth'] = array(
    'title' => 'ReAuth',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_reauth_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_reauth',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 3,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  return $items;
}

/**
 * Determines user access to Refund operation on the prior payment transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_refund($order, $transaction) {
  if (
    !commerce_moneris_api_access_common($order, $transaction)
    // Refund could be done only for Purchase (00) or Capture (02) transactions.
    || (
      $transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE
      && $transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE
    )
  ) {
    return FALSE;
  }

  // A refund can be sent only up to the full value of the original capture or
  // purchase - so if full amount of original transaction was already refunded,
  // we don't want to allow for another refund.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => $transaction->payment_method,
    'instance_id' => $transaction->instance_id,
    'remote_status' => COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND,
    'status' => COMMERCE_PAYMENT_STATUS_SUCCESS,
  );
  $refunded_amount = 0;
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $refund_transaction) {
    if ($refund_transaction->payload['related_order_id'] == $transaction->payload['unique_order_id']) {
      $refunded_amount += $refund_transaction->amount;
    }
  }
  // Refund transactions have negative amounts, so we need to check their
  // absolute amounts.
  if (abs($refunded_amount) >= $transaction->amount) {
    return FALSE;
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determines user access to Capture operation on the prior authorisation
 * transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_capture($order, $auth_transaction) {
  if (
    !commerce_moneris_api_access_common($order, $auth_transaction)
    // Capture could be done only for PreAuth/ReAuth (01) transactions.
    || $auth_transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH
  ) {
    return FALSE;
  }

  // A PreAuth or ReAuth transaction can be captured only once, therefore we
  // need to make sure that there are no already existing successful capture
  // (or reverse) transactions for this authorisation transaction.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => $auth_transaction->payment_method,
    'instance_id' => $auth_transaction->instance_id,
    'remote_status' => COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE,
    'status' => array(
      COMMERCE_PAYMENT_STATUS_SUCCESS,
      COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED,
    ),
  );
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $capture_transaction) {
    if ($capture_transaction->payload['related_order_id'] == $auth_transaction->payload['unique_order_id']) {
      return FALSE;
    }
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $auth_transaction);
}

/**
 * Determines user access to Reverse operation on the prior authorisation
 * transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_reverse($order, $auth_transaction) {
  if (
    !commerce_moneris_api_access_common($order, $auth_transaction)
    // Reverse could be done only for PreAuth (01) transactions.
    || $auth_transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH
  ) {
    return FALSE;
  }

  // Reverse could be done only on the full amount of PreAuth transaction,
  // therefore we need to make sure that there is no already existing
  // successful capture transaction for this authorisation transaction.
  // Also, no already existing reverse transaction either.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => $auth_transaction->payment_method,
    'instance_id' => $auth_transaction->instance_id,
    'remote_status' => COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE,
    'status' => array(
      COMMERCE_PAYMENT_STATUS_SUCCESS,
      COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED,
    ),
  );
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $capture_transaction) {
    if (
      !empty($capture_transaction->payload['related_order_id'])
      && $capture_transaction->payload['related_order_id'] == $auth_transaction->payload['unique_order_id']
    ) {
      return FALSE;
    }
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $auth_transaction);
}

/**
 * Determines user access to ReAuth operation on the prior authorisation
 * transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_reauth($order, $auth_transaction) {
  if (
    !commerce_moneris_api_access_common($order, $auth_transaction)
    // Reverse could be done only for PreAuth (01) transactions.
    || $auth_transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH
  ) {
    return FALSE;
  }

  // ReAuth should only be available for PreAuth transactions, for which only
  // part of the authorised amount was already captured (but not all of it).
  // That's because PreAuth may be captured only once, and if it is done for
  // the smaller amount than original authorisation, ReAuth is needed for the
  // merchant to be able to capture the remaining amount.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => $auth_transaction->payment_method,
    'instance_id' => $auth_transaction->instance_id,
    'remote_status' => array(
      COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH,
      COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE,
    ),
    'status' => array(
      COMMERCE_PAYMENT_STATUS_SUCCESS,
      COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED,
    ),
  );
  $captured_amount = 0;
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $capture_transaction) {
    if (
      !empty($capture_transaction->payload['related_order_id'])
      && $capture_transaction->payload['related_order_id'] == $auth_transaction->payload['unique_order_id']
    ) {
      $captured_amount += $capture_transaction->amount;
    }
  }
  // If nothing was yet captured, or captured amount equals or is higher than
  // initially authorised amount, ReAuth should not be available.
  if (
    $captured_amount == 0
    || $captured_amount >= $auth_transaction->amount
  ) {
    return FALSE;
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $auth_transaction);
}

/**
 * Determines generic access to am operation on the prior transactions.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_common($order, $transaction) {
  // Return FALSE if the original transaction wasn't for Moneris API,
  // wasn't successful, or we don't have its remote_id.
  if (
    $transaction->payment_method != 'commerce_moneris_api'
    || (
      $transaction->status != COMMERCE_PAYMENT_STATUS_SUCCESS
      && $transaction->status != COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED
    )
    || empty($transaction->remote_id)
  ) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Implements hook_help().
 */
function commerce_moneris_api_help($path, $arg) {
  switch ($path) {
    // Display help on Moneris transaction operations on order Payment page.
    case 'admin/commerce/orders/%/payment':
      // Display help only if at least one Moneris API transaction already exists.
      if (commerce_payment_transaction_load_multiple(array(), array('order_id' => $arg[3], 'payment_method' => 'commerce_moneris_api'))) {
        return '<p>' . t('Possible operations on <em>Moneris API</em> transactions:') . '</p><p><ul>'
          . '<li>' . t('<b><em>Refund</em></b> will credit a specified amount to the cardholderâ€™s credit card. A <em>Refund</em> can be sent up to the full value of the original <em>Capture</em> or <em>Purchase</em>.') . '</li>'
          . '<li>' . t('<b><em>PreAuth</em></b> transactions <b>must</b> be reversed if they are not to be captured. <em>PreAuth</em> may only be captured <b>once</b> for less than, equal to, or greater than the original <em>PreAuth</em> amount. If the <em>PreAuth</em> is captured for less than its total amount, then a <em>ReAuth</em> is first required to be able to capture the remainder.') . '</li>'
          . '<li>' . t('<b><em>ReAuth</em></b> will only allow the merchant to re-authorise funds on the credit card used in the original transaction for no more than the uncaptured amount.') . '</li>'
          . '<li>' . t('<b><em>Capture</em></b> transaction is used to secure the funds locked by a <em>PreAuth</em> or <em>ReAuth</em> transaction.') . '</li>'
          . '<li>' . t('<b><em>Reverse</em></b> transaction is used to release the funds locked by a <em>PreAuth</em> or <em>ReAuth</em> transaction.') . '</li>'
          . '</ul></p>';
      }
  }
}

/**
 * Payment method callback: settings form.
 */
function commerce_moneris_api_settings_form($settings = array()) {
  // Merge default settings into the stored settings array.
  // Settings are stored in multi-level array, so we need recursive merge. And
  // actually replace instead of merge, to make sure the default settings are
  // correctly overriden by custom user settings (array_merge_recursive() would
  // just add new array elements instead of overriding existing ones).
  $settings = array_replace_recursive(commerce_moneris_api_settings_default(), $settings);

  $form = array();

  $form['gateway'] = array(
    '#type' => 'select',
    '#title' => t('Gateway'),
    '#options' => commerce_moneris_gateways(TRUE),
    '#default_value' => $settings['gateway'],
  );

  $form['server'] = array(
    '#type' => 'radios',
    '#title' => t('Environment'),
    '#options' => commerce_moneris_environments(TRUE),
    '#default_value' => $settings['server'],
  );

  // Collect Moneris Store ID and API Token for each available environment.
  foreach (commerce_moneris_gateways() as $gateway_id => $gateway) {
    foreach (commerce_moneris_environments() as $environment_id => $environment) {

      $form[$gateway_id][$environment_id]['store_id'] = array(
        '#type' => 'textfield',
        '#title' => t('@gateway @environemnt Store ID', array(
          '@gateway' => $gateway,
          '@environemnt' => $environment,
        )),
        '#default_value' => $settings[$gateway_id][$environment_id]['store_id'],
        '#states' => array(
          'visible' => array(
            ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
            ':input[name="parameter[payment_method][settings][payment_method][settings][server]"]' => array('value' => $environment_id),
          ),
          'required' => array(
            ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
            ':input[name="parameter[payment_method][settings][payment_method][settings][server]"]' => array('value' => $environment_id),
          ),
        ),
      );

      $form[$gateway_id][$environment_id]['api_token'] = array(
        '#type' => 'textfield',
        '#title' => t('@gateway @env API Token', array(
          '@gateway' => $gateway,
          '@env' => $environment,
        )),
        '#default_value' => $settings[$gateway_id][$environment_id]['api_token'],
        '#states' => array(
          'visible' => array(
            ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
            ':input[name="parameter[payment_method][settings][payment_method][settings][server]"]' => array('value' => $environment_id),
          ),
          'required' => array(
            ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
            ':input[name="parameter[payment_method][settings][payment_method][settings][server]"]' => array('value' => $environment_id),
          ),
        ),
      );
    }

    $form[$gateway_id]['txn_type'] = array(
      '#type' => 'radios',
      '#title' => t('Default @gateway credit card transaction type', array('@gateway' => $gateway)),
      '#options' => commerce_moneris_api_get_transaction_types($gateway_id),
      '#default_value' => $settings[$gateway_id]['txn_type'],
      '#states' => array(
        'visible' => array(
          ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
        ),
        'required' => array(
          ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
        ),
      ),
    );

    $form[$gateway_id]['extra'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Extra features'),
      '#description' => t('To have the eFraud features added to your merchant profile, please call Moneris Service Centre to have your profile updated.'),
      '#options' => array(
        'cvd' => t('eFraud: Enable CVD (Card Validation Digits)'),
        'avs' => t('eFraud: Enable AVS verification (Address Verification System)'),
        'ssl' => t('Use SSL'),
      ),
      '#default_value' => $settings[$gateway_id]['extra'],
      '#states' => array(
        'visible' => array(
          ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
        ),
      ),
    );

    $form[$gateway_id]['curl_certificate_path'] = array(
      '#type' => 'textfield',
      '#title' => t('cURL certificate'),
      '#description' => t('Path to the cURL certificate file <em>cacert.pem</em>, either absolute or relative to Drupal installation (including certificate file name - for example <em>/etc/ssl/certs/cacert.pem</em>). You can download it from <a href="@download_url">CA Extract page</a>.', array('@download_url' => url('http://curl.haxx.se/docs/caextract.html'))),
      '#default_value' => $settings[$gateway_id]['curl_certificate_path'],
      '#states' => array(
        'visible' => array(
          ':input[name="parameter[payment_method][settings][payment_method][settings][gateway]"]' => array('value' => $gateway_id),
          ':input[name="parameter[payment_method][settings][payment_method][settings][' . $gateway_id . '][extra][ssl]"]' => array('checked' => TRUE),
        ),
        'required' => array(
          ':input[name="parameter[payment_method][settings][payment_method][settings][' . $gateway_id . '][extra][ssl]"]' => array('checked' => TRUE),
        ),
      ),
    );

  }

  $form['log'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Log the following messages for debugging'),
    '#options' => array(
      'request' => t('API request messages'),
      'response' => t('API response messages'),
    ),
    '#default_value' => $settings['log'],
  );

  return $form;
}

/**
 * Returns default settings for the Moneris API payment method.
 *
 * @see commerce_moneris_api_settings_form()
 */
function commerce_moneris_api_settings_default() {
  $default_settings = array(
    'gateway' => COMMERCE_MONERIS_USA,
    'server' => 'test',
    'log' => array(),
  );
  foreach (commerce_moneris_gateways() as $gateway_id => $gateway) {
    foreach (commerce_moneris_environments() as $environment_id => $environment) {
      $default_settings[$gateway_id][$environment_id]['store_id'] = '';
      $default_settings[$gateway_id][$environment_id]['api_token'] = '';
    }
    // For default transaction type we return key of the first defined type.
    $transaction_types = commerce_moneris_api_get_transaction_types($gateway_id);
    reset($transaction_types);
    $default_settings[$gateway_id]['txn_type'] = key($transaction_types);
    $default_settings[$gateway_id]['extra'] = array(
      'avs' => 'avs',
      'cvd' => 'cvd',
      'ssl' => FALSE,
    );
    $default_settings[$gateway_id]['curl_certificate_path'] = '';
  }
  return $default_settings;
}

/**
 * Payment method callback: checkout form.
 */
function commerce_moneris_api_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  return commerce_payment_credit_card_form(array('code' => ''));
}

/**
 * Payment method callback: checkout form validation.
 */
function commerce_moneris_api_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');

  // Validate the credit card fields.
  $settings = array(
    'form_parents' => array_merge($form_parents, array('credit_card')),
  );

  if (!commerce_payment_credit_card_validate($pane_values['credit_card'], $settings)) {
    return FALSE;
  }
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_moneris_api_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  return commerce_moneris_api_transaction_purchase($payment_method, $order, $charge, $pane_values);
}

/**
 * Prepares and posts data to Moneris API, processes its response
 * and creates a payment transaction.
 *
 * @param array $payment_method
 *   The payment method instance object used to charge this payment.
 * @param object $order
 *   The order object the payment applies to.
 * @param array $charge
 *   An array indicating the amount and currency code to charge.
 * @param array $values
 *   The values submitted by user.
 */
function commerce_moneris_api_transaction_purchase($payment_method, $order, $charge, $values) {
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];
  $transaction_type = $payment_method['settings'][$gateway]['txn_type'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $order->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Tax amount - as seen in commerce_paypal_ec_itemise_order().
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();
  $tax_amount = (module_exists('commerce_tax')) ? commerce_round(COMMERCE_ROUND_HALF_UP, commerce_tax_total_amount($order_total['data']['components'], FALSE, $order_total['currency_code'])) : 0;

  // Create transaction data.
  $txn_array = array(
    'type' => $transaction_type,
    'order_id' => $unique_order_id,
    'amount' => number_format(commerce_currency_amount_to_decimal($charge['amount'], $charge['currency_code']), 2, '.', ''),
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
    // Optional fields.
    'cust_id' => $order->uid,
    'dynamic_descriptor' => variable_get('site_name', ''),
    // Optional Level 2 variables.
    'commcard_invoice' => $order->order_number,
    'commcard_tax_amount' => $tax_amount,
  );
  // We don't want credit card data to go through alter hook implementations
  // below, so we add them only after they have been already called.

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_txnarray', $txn_array, $order);

  // Prepare credit card data to be added to transaction array.
  $cc_data = array(
    'pan' => $values['credit_card']['number'],
    'expdate' => substr($values['credit_card']['exp_year'], 2, 2) . $values['credit_card']['exp_month'],
    'cvd_indicator' => 1,
    'cvd_value' => $values['credit_card']['code'],
  );
  // With array_merge() all credit card details that might have been added
  // in hook_commerce_moneris_txnarray_alter() implementations will be
  // overwritten by our $cc_data values.
  $txn_array = array_merge($txn_array, $cc_data);

  // Load native Moneris library relevant to selected gateway.
  module_load_include('php', 'commerce_moneris_api', "includes/$gateway/mpgClasses");

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // eFraud: CVD (Card Validation Digits) verification.
  if (!empty($payment_method['settings'][$gateway]['extra']['cvd'])) {
    $cvd_template = array(
      'cvd_indicator' => $txn_array['cvd_indicator'],
      'cvd_value' => $txn_array['cvd_value'],
    );
    $mpg_cvd_info = new mpgCvdInfo($cvd_template);
    $mpg_transaction->setCvdInfo($mpg_cvd_info);
  }

  // eFraud: AVS (Address Verification Service) verification.
  if (!empty($payment_method['settings'][$gateway]['extra']['avs'])) {
    if ($order_wrapper->commerce_customer_billing->value()) {
      $billing_address = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();
      // For the moment we assume that street number will be the first element
      // of thoroughfare value, with the remaining part being street name.
      $thoroughfare = explode(' ', $billing_address['thoroughfare'], 2);

      $avs_template = array(
        'avs_street_number' => $thoroughfare[0],
        'avs_street_name' => $thoroughfare[1],
        'avs_zipcode' => $billing_address['postal_code'],
      );
      $mpg_avs_info = new mpgAvsInfo($avs_template);
      $mpg_transaction->setAvsInfo($mpg_avs_info);
    }
  }

  // Send the transaction request to Moneris.
  $mpg_response = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($mpg_response, $transaction);
}

/**
 * Refunds a transaction.
 *
 * @param object $purchase_transaction
 *   Transaction to be refunded.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 */
function commerce_moneris_api_transaction_refund($purchase_transaction, $amount) {
  $payment_method = commerce_payment_method_instance_load($purchase_transaction->instance_id);
  $order = commerce_order_load($purchase_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $purchase_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = -commerce_currency_decimal_to_amount($amount, $purchase_transaction->currency_code);
  $transaction->currency_code = $purchase_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $purchase_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_refund' : 'refund',
    'order_id' => $purchase_transaction->payload['unique_order_id'],
    'amount' => number_format($amount, 2, '.', ''),
    'txn_number' => $purchase_transaction->remote_id,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_txnarray', $txn_array, $order);

  // Load native Moneris library relevant to selected gateway.
  module_load_include('php', 'commerce_moneris_api', "includes/$gateway/mpgClasses");

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Refunds a transaction.
 *
 * @param object $purchase_transaction
 *   Transaction to be refunded.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 */
function commerce_moneris_api_transaction_capture($purchase_transaction, $amount) {
  $payment_method = commerce_payment_method_instance_load($purchase_transaction->instance_id);
  $order = commerce_order_load($purchase_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $purchase_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = commerce_currency_decimal_to_amount($amount, $purchase_transaction->currency_code);
  $transaction->currency_code = $purchase_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $purchase_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Tax amount - as seen in commerce_paypal_ec_itemise_order().
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();
  $tax_amount = (module_exists('commerce_tax')) ? commerce_round(COMMERCE_ROUND_HALF_UP, commerce_tax_total_amount($order_total['data']['components'], FALSE, $order_total['currency_code'])) : 0;

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_completion' : 'completion',
    'order_id' => $purchase_transaction->payload['unique_order_id'],
    'comp_amount' => number_format($amount, 2, '.', ''),
    'txn_number' => $purchase_transaction->remote_id,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
    // Optional Level 2 variables.
    'commcard_invoice' => $order->order_number,
    'commcard_tax_amount' => $tax_amount,
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_txnarray', $txn_array, $order);

  // Load native Moneris library relevant to selected gateway.
  module_load_include('php', 'commerce_moneris_api', "includes/$gateway/mpgClasses");

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Refunds a transaction.
 *
 * @param object $purchase_transaction
 *   Transaction to be refunded.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 */
function commerce_moneris_api_transaction_reverse($purchase_transaction, $amount) {
  $payment_method = commerce_payment_method_instance_load($purchase_transaction->instance_id);
  $order = commerce_order_load($purchase_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $purchase_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = -commerce_currency_decimal_to_amount($amount, $purchase_transaction->currency_code);
  $transaction->currency_code = $purchase_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $purchase_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Tax amount - as seen in commerce_paypal_ec_itemise_order().
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();
  $tax_amount = (module_exists('commerce_tax')) ? commerce_round(COMMERCE_ROUND_HALF_UP, commerce_tax_total_amount($order_total['data']['components'], FALSE, $order_total['currency_code'])) : 0;

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_completion' : 'completion',
    'order_id' => $purchase_transaction->payload['unique_order_id'],
    'comp_amount' => '0.00',
    'txn_number' => $purchase_transaction->remote_id,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
    // Optional Level 2 variables.
//    'commcard_invoice' => $order->order_number,
//    'commcard_tax_amount' => $tax_amount,
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_txnarray', $txn_array, $order);

  // Load native Moneris library relevant to selected gateway.
  module_load_include('php', 'commerce_moneris_api', "includes/$gateway/mpgClasses");

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Refunds a transaction.
 *
 * @param object $purchase_transaction
 *   Transaction to be refunded.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 */
function commerce_moneris_api_transaction_reauth($preauth_transaction, $amount) {
  $payment_method = commerce_payment_method_instance_load($preauth_transaction->instance_id);
  $order = commerce_order_load($preauth_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $preauth_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = commerce_currency_decimal_to_amount($amount, $preauth_transaction->currency_code);
  $transaction->currency_code = $preauth_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $preauth_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_reauth' : 'reauth',
    'order_id' => $unique_order_id,
    'orig_order_id' => $preauth_transaction->payload['unique_order_id'],
    'txn_number' => $preauth_transaction->remote_id,
    'amount' => $amount,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_txnarray', $txn_array, $order);

  // Load native Moneris library relevant to selected gateway.
  module_load_include('php', 'commerce_moneris_api', "includes/$gateway/mpgClasses");

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Posts data to Moneris API.
 *
 * @param object $mpg_transaction
 *   The mpgTransaction object which mpgRequest will be created from.
 * @param array $payment_method
 *   The payment method instance object used to charge this payment.
 * @param object $order
 *   The order object the payment applies to.
 */
function commerce_moneris_api_request($mpg_transaction, $payment_method, $order) {
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];
  $store_id = $payment_method['settings'][$gateway][$environment]['store_id'];
  $api_token = $payment_method['settings'][$gateway][$environment]['api_token'];
  $cacert_path = (!empty($payment_method['settings'][$gateway]['extra']['ssl'])) ? $payment_method['settings'][$gateway]['curl_certificate_path'] : '';

  // Load native Moneris library relevant to selected gateway.
  module_load_include('php', 'commerce_moneris_api', "includes/$gateway/mpgClasses");

  // Mask and log transaction object.
  if (!empty($payment_method['settings']['log']['request'])) {
    // We can't change original transaction details, so let's work on its copy.
    $log = clone($mpg_transaction);
    // Mask the credit card number, expiraton date and CVV code
    // before saving it to the dblog.
    if (!empty($log->txn['pan'])) {
      $log->txn['pan'] = str_repeat('X', strlen($log->txn['pan']) - 4) . substr($log->txn['pan'], -4);
    }
    if (!empty($log->txn['expdate'])) {
      $log->txn['expdate'] = str_repeat('X', strlen($log->txn['expdate']));
    }
    if (!empty($log->txn['cvd_value'])) {
      $log->txn['cvd_value'] = str_repeat('X', strlen($log->txn['cvd_value']));
    }
    if (!empty($log->cvdInfo->params['cvd_value'])) {
      $log->cvdInfo->params['cvd_value'] = str_repeat('X', strlen($log->cvdInfo->params['cvd_value']));
    }
    commerce_moneris_log('commerce_moneris_api', 'request: <pre>' . check_plain(print_r($log, TRUE)) . '</pre>', $order->order_id, $gateway, $environment);
  }

  // Prepare Moneris request object and send it to their gateway.
  $mpg_request = new mpgRequest($mpg_transaction);
  $mpg_result = new mpgHttpsPost($store_id, $api_token, $mpg_request, $environment, $cacert_path);
  $mpg_response = $mpg_result->getMpgResponse();

  // Add original cURL response to received mpgResponse object.
  // Including cURL error if any.

  // Log the full response.
  if (!empty($payment_method['settings']['log']['response'])) {
    // Log the cURL response.
    $curl_log = array('response' => $mpg_result->getCurlResponse());
    if ($curl_error = $mpg_result->getCurlError()) {
      $curl_log += $curl_error;
    }
    commerce_moneris_log('commerce_moneris_api', 'cURL response: <pre>' . check_plain(print_r($curl_log, TRUE)) . '</pre>', $order->order_id, $gateway, $environment);
    // Log the gateway response.
    commerce_moneris_log('commerce_moneris_api', 'Moneris response: <pre>' . check_plain(print_r($mpg_response->responseData, TRUE)) . '</pre>', $order->order_id, $gateway, $environment);
  }

  return $mpg_response->responseData;
}

/**
 * Processed the response received from Moneris.
 *
 * @param array $response_data
 *   Moneris mpgResponse->response_data array.
 * @param array $transaction
 *   The commerce payment transaction.
 *
 * @return bool
 *   Boolean indicating whether the transaction was successful or not.
 */
function commerce_moneris_api_response_process($response_data, $transaction) {
  // Log received response.
  $transaction->payload['responseData'] = $response_data;

  // eSelectPlus Response Handling guide says that first step of making sure
  // the transaction was successful is checking values of Complete, TimedOut
  // ResponseCode and Message parameters.
  if (
    empty($response_data['Complete']) || $response_data['Complete'] != 'true'
    || empty($response_data['TimedOut']) || $response_data['TimedOut'] != 'false'
    || empty($response_data['ResponseCode']) || $response_data['ResponseCode'] == 'null'
  ) {
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $transaction->message = $response_data['Message'];
  }
  // Transaction was processed successfully
  // (although still might have been declined).
  else {
    // Response code will be returned as a string like '027', so we need
    // to convert it to a proper integer first before checking its value.
    $response_code = (int) $response_data['ResponseCode'];

    // Transaction was approved.
    if ($response_code >= 0 && $response_code <= 49) {
      $transaction->status = commerce_moneris_api_get_transaction_success_status($response_data['TransType'], $response_data['TransAmount']);
    }
    // Transaction was declined.
    else {
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    }

    $transaction->remote_id = $response_data['TransID'];

    // Build transaction message from main status message and all validators.
    $transaction->message = t('@txn_type: !message', array(
      '@txn_type' => commerce_moneris_api_get_transaction_type($transaction),
      '!message' => $response_data['Message'],
    ));
    // Add eFraud information if available.
    if (!empty($response_data['CvdResultCode']) && $response_data['CvdResultCode'] != 'null') {
      $transaction->message .= '<br />' . t('CVD result: @result', array('@result' => commerce_moneris_api_get_cvd_response($response_data['CvdResultCode'])));
    }
    if (!empty($response_data['AvsResultCode']) && $response_data['AvsResultCode'] != 'null') {
      $transaction->message .= '<br />' . t('AVS result: @result', array('@result' => commerce_moneris_api_get_avs_response($response_data['AvsResultCode'], $response_data['CardType'])));
    }
    if (!empty($response_data['CavvResultCode']) && $response_data['CavvResultCode'] != 'null') {
      $transaction->message .= '<br />' . t('CAVV result: @result', array('@result' => commerce_moneris_api_get_cavv_response($response_data['CavvResultCode'])));
    }
  }

  // Store the type of transaction in the remote status.
  $transaction->remote_status = $response_data['TransType'];

  commerce_payment_transaction_save($transaction);

  if ($transaction->status == COMMERCE_PAYMENT_STATUS_FAILURE) {
    drupal_set_message(t('We encountered an error processing your transaction. Please enter your information again or try a different card.'), 'error');
    return FALSE;
  }

  return TRUE;
}

/**
 * Returns supported transaction types for a specified gateway (country).
 *
 * @param string $gateway_id
 *   A gateway ID indicating which country to return transaction types for.
 * @param bool $translated
 *   A boolean indicating whether returned strings should be translated or not.
 *
 * @return array
 *   An array of available transaction types for a specified gateway (country).
 */
function commerce_moneris_api_get_transaction_types($gateway_id, $translated = FALSE) {
  $transaction_types = array(
    COMMERCE_MONERIS_USA => array(
      'us_purchase' => t('Purchase'),
      'us_preauth' => t('PreAuth'),
    ),
    COMMERCE_MONERIS_CANADA => array(
      'purchase' => t('Purchase'),
      'preauth' => t('PreAuth'),
    ),
  );

  if ($translated) {
    $transaction_types[$gateway_id] = array_map('t', $transaction_types[$gateway_id]);
  }

  return $transaction_types[$gateway_id];
}

/**
 * Returns transaction type for specific TransType response code.
 *
 * @param string $trans_type
 *   TransType response code received in response from Moneris API.
 *
 * @return string
 *   Transaction type.
 */
function commerce_moneris_api_get_transaction_type($transaction) {
  switch ($transaction->payload['responseData']['TransType']) {
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE:
      return 'Purchase';
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH:
      return (!empty($transaction->payload['related_order_id'])) ? 'ReAuth' : 'PreAuth';
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE:
      return ($transaction->payload['responseData']['TransAmount'] == '0.00') ? 'Reverse' : 'Capture';
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND:
      return 'Refund';
  }
}

/**
 * Returns Drupal-Commerce compatible transaction status for a transaction type.
 *
 * @param string $trans_type
 *   Moneris transaction type.
 * @param $amount
 *   Transaction amount.
 *
 * @return string
 *   Drupal Commerce-compatible transaction status for a given transaction type.
 */
function commerce_moneris_api_get_transaction_success_status($trans_type, $amount) {
  switch ($trans_type) {
    // Purchase, Refund.
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE:
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND:
      return COMMERCE_PAYMENT_STATUS_SUCCESS;
    // PreAuth.
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH:
      return COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED;
    // Capture/Reverse.
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE:
      return ($amount != '0.00') ? COMMERCE_PAYMENT_STATUS_SUCCESS : COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED;
  }
}

/**
 * Returns CVD indicator value description for specific CVD response code.
 *
 * @param string $cvd_response_code
 *   CVD response code received in response from Moneris API.
 *
 * @return string
 *   CVD indicator value description.
 */
function commerce_moneris_api_get_cvd_indicator($cvd_response_code) {
  switch (substr($cvd_response_code, 0, 1)) {
    case '0': return t('CVD value is deliberately bypassed or is not provided by the merchant.');
    case '1': return t('CVD value is present.');
    case '2': return t('CVD value is on the card, but is illegible.');
    case '9': return t('Cardholder states that the card has no CVD imprint.');
  }
  return t('Unknown CVD indicator.');
}

/**
 * Returns description for specific CVD response code.
 *
 * @param $cvd_response_code
 *   CVD code received in response from Moneris API.
 *
 * @return string
 *   CVD response code description.
 */
function commerce_moneris_api_get_cvd_response($cvd_response_code) {
  switch (substr($cvd_response_code, 1)) {
    case 'M': return t('Match');
    case 'Y': return t('Match for AmEx');
    case 'N': return t('No Match');
    case 'P': return t('Not Processed');
    case 'S': return t('CVD should be on the card, but Merchant has indicated that CVD is not present');
    case 'R': return t('Retry for AmEx');
    case 'U': return t('Issuer is not a CVD participant');
  }
  return t('Invalid Response Code');
}

/**
 * Returns description for specific AVS response code.
 *
 * @param string $avs_response_code
 *   AVS code received in response from Moneris API.
 * @param string $card_type
 *   Card type code received in response from Moneris API.
 *
 * @return string
 *   AVS response code description.
 */
function commerce_moneris_api_get_avs_response($avs_response_code, $card_type) {
  switch ($card_type) {
    // AVS response codes for Visa, Discover and JCB.
    case 'V':
    // case Discover ?
    case 'C1':
      switch ($avs_response_code) {
        case 'A': return t('Address matches, ZIP does not. Acquirer rights not implied.');
        case 'B': return t('Street addresses match. Zip code not verified due to incompatible formats. (Acquirer sent both street address and zip code.)');
        case 'C': return t('Street addresses not verified due to incompatible formats. (Acquirer sent both street address and zip code.)');
        case 'D': return t('Street addresses and zip codes match.');
        case 'F': return t('Street address and zip code match. Applies to U.K. only');
        case 'G': return t('Address information not verified for international transaction. Issuer is not an AVS participant, or AVS data was present in the request but issuer did not return an AVS result, or Visa performs AVS on behalf of the issuer and there was no address record on file for this account.');
        case 'I': return t('Address information not verified.');
        case 'M': return t('Street address and zip code match.');
        case 'N': return t('No match. Acquirer sent postal/ZIP code only, or street address only, or both zip code and street address. Also used when acquirer requests AVS but sends no AVS data.');
        case 'P': return t('Zip code match. Acquirer sent both zip code and street address but street address not verified due to incompatible formats.');
        case 'R': return t('Retry: system unavailable or timed out. Issuer ordinarily performs AVS but was unavailable. The code R is used by Visa when issuers are unavailable. Issuers should refrain from using this code.');
        case 'U': return t('Address not verified for domestic transaction. Issuer is not an AVS participant, or AVS data was present in the request but issuer did not return an AVS result, or Visa performs AVS on behalf of the issuer and there was no address record on file for this account.');
        case 'W': return t('Not applicable. If present, replaced with â€˜Zâ€™ by Visa. Available for U.S. issuers only.');
        case 'Y': return t('Street address and zip code match.');
        case 'Z': return t('Postal/Zip matches; street address does not match or street address not included in request.');
      }
    // AVS response codes for MasterCard.
    case 'M':
      switch ($avs_response_code) {
        case 'A': return t('Address matches, zip code does not.');
        case 'N': return t('Neither address nor zip code matches.');
        case 'R': return t('Retry; system unable to process.');
        case 'S': return t('AVS currently not supported.');
        case 'U': return t('No data from Issuer/Authorisation system.');
        case 'W': return t('For U.S. Addresses, nine-digit zip code matches, address does not; for address outside the U.S. postal code matches, address does not.');
        case 'X': return t('For U.S. addresses, nine-digit zip code and addresses matches; for addresses outside the U.S., postal code and address match.');
        case 'Y': return t('For U.S. addresses, five-digit zip code and address matches.');
        case 'Z': return t('For U.S. addresses, five digit zip code matches, address does not.');
      }
    // AVS response codes for American Express.
    case 'AX':
      switch ($avs_response_code) {
        case 'A': return t('Billing address matches, zip code does not');
        case 'D': return t('Customer name incorrect, zip code matches');
        case 'E': return t('Customer name incorrect, billing address and zip code match');
        case 'F': return t('Customer name incorrect, billing address matches');
        case 'K': return t('Customer name matches');
        case 'L': return t('Customer name and zip code match');
        case 'M': return t('Customer name, billing address, and zip code match');
        case 'N': return t('Billing address and zip code do not match');
        case 'O': return t('Customer name and billing address match');
        case 'R': return t('System unavailable; retry');
        case 'S': return t('AVS not currently supported');
        case 'U': return t('Information is unavailable');
        case 'W': return t('Customer name, billing address, and zip code are all incorrect');
        case 'Y': return t('Billing address and zip code both match');
        case 'Z': return t('Zip code matches, billing address does not');
      }
  }
  return t('AVS code not recognised.');
}

/**
 * Returns description for specific CAVV response code.
 *
 * @param $cavv_response_code
 *   CAVV code received in response from Moneris API.
 *
 * @return string
 *   CAVV response code description.
 */
function commerce_moneris_api_get_cavv_response($cavv_response_code) {
  switch ($cavv_response_code) {
    case '0': return t('CAVV authentication results invalid.');
    case '1': return t('CAVV failed validation; authentication');
    case '2': return t('CAVV passed validation; authentication');
    case '3': return t('CAVV passed validation; attempt');
    case '4': return t('CAVV failed validation; attempt');
    case '7': return t('CAVV failed validation; attempt (US issued cards only)');
    case '8': return t('CAVV passed validation; attempt (US issued cards only');
    case '9': return t('= CAVV failed validation; attempt (US issued cards only)');
    case 'A': return t('CAVV passed validation; attempt (US issued cards only)');
    case 'B': return t('CAVV passed validation; information only, no liability shift');
  }
  return t('CAVV code not recognised.');
}

/**
 * Returns merchant meaning for specific CAVV response code.
 *
 * @param $cavv_response_code
 *   CAVV code received in response from Moneris API.
 *
 * @return string
 *   CAVV response code merchant meaning.
 */
function commerce_moneris_api_get_cavv_meaning($cavv_response_code) {
  switch ($cavv_response_code) {
    case '0': return t('For this transaction you may not receive protection from chargebacks as a result of using VBV as the CAVV was considered invalid at the time the financial transaction was processed. Please check that you are following the VBV process correctly and passing the correct data in our transactions.');
    case '1': return t('Provided that you have implemented the VBV process correctly the liability for this transaction should remain with the Issuer for chargeback reason codes covered by Verified by Visa.');
    case '2': return t('The CAVV was confirmed as part of the financial transaction. This transaction is a fully authenticated VBV transaction (ECI 5)');
    case '3': return t('The CAVV was confirmed as part of the financial transaction. This transaction is an attempted VBV transaction (ECI 6)');
    case '4': return t('Provided that you have implemented the VBV process correctly the liability for this transaction should remain with the Issuer for chargeback reason codes covered by Verified by Visa.');
    case '7': return t('Please check that you are following the VBV process correctly and passing the correct data in our transactions. Provided that you have implemented the VBV process correctly the liability for this transaction should be the same as an attempted transaction (ECI 6)');
    case '8': return t('The CAVV was confirmed as part of the financial transaction. This transaction is an attempted VBV transaction (ECI 6)');
    case '9': return t('Please check that you are following the VBV process correctly and passing the correct data in our transactions. Provided that you have implemented the VBV process correctly the liability for this transaction should be the same as an attempted transaction (ECI 6)');
    case 'A': return t('The CAVV was confirmed as part of the financial transaction. This transaction is an attempted VBV transaction (ECI 6)');
    case 'B': return t('The CAVV was confirmed as part of the financial transaction. However, this transaction does qualify for the liability shift. Treat this transaction the same as an ECI 7.');
  }
  return t('CAVV code not recognised.');
}
